<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Stable Stabler - The Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    <div class="game-ui">
        <div class="score-item" id="current-score">Score: 0</div>
        <div class="score-item" id="high-score">Highscore: 0</div>
    </div>

<script type="text/javascript">
    const width = window.innerWidth;
    const height = window.innerHeight;
    const unifiedHeightUnit = height * 0.15;
    const centerX = width * 0.5;

    const config = {
        type: Phaser.AUTO,
        width: width,
        height: height,
        transparent: true,
        physics: {
            default: 'matter',
            matter: {
                gravity: { y: 0.8 }, // Reduced from 1 - lighter gravity
                // Add these stability settings
                constraintIterations: 4,
                positionIterations: 8,
                velocityIterations: 6,
                enableSleeping: true, // Allows blocks to "sleep" when stable
                //debug: true
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
        input: {
            keyboard: true
        }
    };

    let game;

    document.fonts.ready.then(() => {
        game = new Phaser.Game(config);
    });

    let currentCameraY = 0;

    let crane;
    let craneSpeed = 0.02;
    let time = 0;

    let blockReady = true;
    let latestBlock = false;

    let scoreText;
    let currentScore;
    let highScoreText;
    let highscore = 0;

    let towerBlocks = [];

    let playerName;

    // Get references to the score elements
    const currentScoreElement = document.getElementById('current-score');
    const highScoreElement = document.getElementById('high-score');

    function showPlayernameModal() {
        const enterNameDialog = document.createElement("dialog");
        enterNameDialog.style.padding = "20px";
        enterNameDialog.style.border = "2px solid white";
        enterNameDialog.style.borderRadius = "10px";
        enterNameDialog.style.margin = "auto";
        enterNameDialog.style.backgroundColor = "white";
        enterNameDialog.style.zIndex = "1000";
        enterNameDialog.style.fontFamily = "CustomFont";

        const enterNameText = document.createElement("h2");
        enterNameText.innerText = "Enter your name";
        enterNameText.style.textAlign = "center";
        enterNameText.style.marginBottom = "10px";
        enterNameText.style.fontFamily = "CustomFont";

        const enterNameField = document.createElement("INPUT");
        enterNameField.setAttribute("type","text");
        enterNameField.style.height = "2rem";
        enterNameField.style.textAlign = "center";
        enterNameField.style.display = "block";
        enterNameField.style.margin = "8px auto";
        enterNameField.style.fontFamily = "CustomFont";
        enterNameField.addEventListener("keydown", (event) => {
            if (event.key === 'Enter'){
                playerName = enterNameField.value
                enterNameDialog.close();
            }
        });

        const enterNameButton = document.createElement("button");
        enterNameButton.innerText = "Let's play!";
        enterNameButton.style.padding = "10px 20px";
        enterNameButton.style.fontSize = "16px";
        enterNameButton.style.display = "block";
        enterNameButton.style.margin = "0 auto";
        enterNameButton.style.fontFamily = "CustomFont";
        enterNameButton.addEventListener("click", (event) => {
            playerName = enterNameField.value
            enterNameDialog.close();
        });
        enterNameButton.addEventListener("submit", (event) => {
            playerName = enterNameField.value
            enterNameDialog.close();
        });

        enterNameDialog.appendChild(enterNameText);
        enterNameDialog.appendChild(enterNameField);
        enterNameDialog.appendChild(enterNameButton);
        document.body.appendChild(enterNameDialog);
        enterNameDialog.showModal();
    }

    function restartGame() {
        const restartDialog = document.createElement("dialog");
        restartDialog.style.padding = "20px";
        restartDialog.style.border = "2px solid white";
        restartDialog.style.borderRadius = "10px";
        restartDialog.style.margin = "auto";
        restartDialog.style.backgroundColor = "white";
        restartDialog.style.zIndex = "1000";
        
        const gameOverText = document.createElement("h2");
        gameOverText.innerText = "Game Over!";
        gameOverText.style.marginBottom = "10px";
        
        const scoreText = document.createElement("p");
        scoreText.innerText = `Your Score: ${currentScore}`;
        scoreText.style.marginBottom = "20px";
        scoreText.style.fontFamily = "CustomFont";
        
        const restartButton = document.createElement("button");
        restartButton.innerText = "RESTART";
        restartButton.style.display = "block";
        restartButton.style.padding = "10px 20px";
        restartButton.style.fontSize = "16px";
        restartButton.style.fontFamily = "CustomFont";
        restartButton.style.margin = "0 auto";
        restartButton.addEventListener("click", (event) => {
            // Close and remove dialog
            restartDialog.close();
            document.body.removeChild(restartDialog);
            
            // Now destroy the old game and create new one
            if (game) {
                game.destroy(true);
            }
            
            // Reset all game variables to their initial state
            currentCameraY = 0;
            time = 0;
            blockReady = true;
            latestBlock = false;
            currentScore = 0;
            towerBlocks = [];
            
            // Create new game
            game = new Phaser.Game(config);
        });

        restartDialog.appendChild(gameOverText);
        restartDialog.appendChild(scoreText);
        restartDialog.appendChild(restartButton);
        document.body.appendChild(restartDialog);
        restartDialog.showModal();
    }

    async function getHighscore(){
        try {
            const response = await fetch(`{{VITE_BASE_API_URL}}/highscore?mode=singleplayer`,{
                method: "GET",
                headers: {
                    "Content-Type": "application/json"
                }
            })

            if(response.ok){
                const data = await response.json();

                if(data && data.length > 0){
                    data.forEach((el) => {
                        if(el.score > highscore){
                            highscore = el.score;
                        }

                        // Update HTML element instead of Phaser text
                        highScoreElement.textContent = 'Highscore: ' + highscore;
                    })
                }
            } else {
                console.error("Failed to get score");
            }
        } catch (error) {
            console.error("Error while getting score:", error);
            return null;
        }
    }

    async function saveScore(score, playerName = "Anonymous"){
        try {
            const requestBody = {
                "player": playerName,
                "score": score,
                "mode": "singleplayer",
                "team": "red"
            };
            
            const response = await fetch(`{{VITE_BASE_API_URL}}/highscore`,{
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody)
            })

            if(response.ok){
                console.log("Score saved successfully");
            } else {
                console.error("Failed to save score");
            }
        } catch (error) {
            console.error("Error while saving score:", error);
        }
    }

    function preload() {
        this.load.image('crane', '../assets/png/crane.png');
        this.load.image('rope', '../assets/png/rope.png');
        this.load.image('redBlockTexture', '../assets/png/block-red.png');
        this.load.image('redBlockStartTexture', '../assets/png/start-block-red.png');

        this.load.on('loaderror', function (file) {
            console.error('Failed to load:', file.src);
        });
    }

    function create() {
        
        showPlayernameModal()
        const boundaryThickness = 50;
        
        const leftWall = this.matter.add.rectangle(-25, 0, boundaryThickness, 20000, { 
            isStatic: true 
        });
        leftWall.label = 'Rectangle Body';
        
        const rightWall = this.matter.add.rectangle(width + 25, 0, boundaryThickness, 20000, { 
            isStatic: true 
        });
        rightWall.label = 'Rectangle Body';

        const bottomWall = this.matter.add.rectangle(width/2, height + 1000, width * 2, boundaryThickness, { 
            isStatic: true 
        });
        bottomWall.label = 'Rectangle Body';

        // Set up camera
        this.cameras.main.setBounds(0, -10000, width, 20000);

        // Create crane with floor attached
        crane = this.matter.add.image(centerX, 0, 'crane');
        const scaleToFitCrane = unifiedHeightUnit / (crane.height*2);
        crane.setScale(scaleToFitCrane);
        crane.setStatic(true);
        crane.body.label = 'crane';

        rope = this.add.image(
          centerX, 
          0, // Initial position
          'rope'
        );
        rope.setScale( scaleToFitCrane/3 );


        attachedFloor = this.add.image(
          centerX, 
          0, // Initial position
          'redBlockTexture'
        )
        .setDepth(-1);
        const scaleToFitAttachedFloor = unifiedHeightUnit / attachedFloor.height;
        attachedFloor.setScale(scaleToFitAttachedFloor);


        // Create ground
        const ground = this.add.graphics()
            .fillStyle(0xA52A2A)
            .fillRect(0, 0, width, unifiedHeightUnit)
            .generateTexture('groundTexture', width, 40)
            .destroy();

        this.matter.add.image(width/2, height - unifiedHeightUnit/6, 'groundTexture', null, {   
            isStatic: true 
        });

        // Create ground floor
        let groundFloor = this.matter.add.image(
            width/2,
            height - unifiedHeightUnit/6 - unifiedHeightUnit/2,
            'redBlockStartTexture', null, 
            { isStatic: true }
        );
        groundFloor.body.label = 'groundFloor';

        const scaleToFitGroundFloor = unifiedHeightUnit / groundFloor.height;
        groundFloor.setScale(scaleToFitGroundFloor);

        // Handle collisions with boundaries (game over)
        this.matter.world.on('collisionstart', function (event) {
            event.pairs.forEach(function (pair) {
                const { bodyA, bodyB } = pair;
                
                if (bodyA.isStatic && bodyA.label === 'Rectangle Body' && !bodyB.isStatic) {
                    saveScore(currentScore, playerName);
                    
                    // Pause the game instead of destroying it
                    if (game && game.scene.scenes[0]) {
                        game.scene.scenes[0].matter.world.pause();
                        game.scene.scenes[0].input.enabled = false;
                    }
                    
                    // Show restart dialog immediately (no timeout needed)
                    restartGame();
                } 
            });
        });

        // Handle collisions with blocks (camera movement)
        this.matter.world.on('collisionstart', function (event) {
            event.pairs.forEach(function (pair) {
                const { bodyA, bodyB } = pair;

                if(latestBlock && (bodyA === latestBlock.body || bodyB === latestBlock.body)){
                    const otherBody = bodyA === latestBlock.body ? bodyB : bodyA;

                    if (otherBody.label === 'groundFloor' || otherBody.label === 'buildingBlock') {
                        blockReady = true;
                        towerBlocks.push(latestBlock);

                        // Move camera up
                        const currentCameraY = game.scene.scenes[0].cameras.main.scrollY;
                        
                        if(towerBlocks.length > 1) {
                          newCameraY = currentCameraY - unifiedHeightUnit;
                          game.scene.scenes[0].tweens.add({
                              targets: game.scene.scenes[0].cameras.main,
                              scrollY: newCameraY,
                              duration: 500, // 1.5 seconds - adjust this for speed
                              ease: 'Power2.easeOut' // Smooth easing
                          });
                        }
                        
                        
                        console.log(`Camera moved to: ${game.scene.scenes[0].cameras.main.scrollY}`);
                        
                        latestBlock = null;
                    }
                }
            });
        });
    
        // Remove the Phaser text creation and replace with:
        currentScore = 0;
        currentScoreElement.textContent = 'Score: 0';
        
        getHighscore();
    }

    function update() {
        // Move crane
        const cameraY = this.cameras.main.scrollY;
        const centerXMovement = width * 0.5;
        const moveRange = width * 0.25;

        time += craneSpeed;
        crane.x = centerXMovement + Math.sin(time) * moveRange;
        crane.y = cameraY + crane.displayHeight/2;  

        rope.x = crane.x;
        rope.y = crane.y + crane.displayHeight;

        // In the update function
        attachedFloor.x = crane.x;
        attachedFloor.y = crane.y + crane.displayHeight/2 + attachedFloor.displayHeight;

        // Handle spacebar input - changed from isDown to wasJustDown
        const spacBar = this.input.keyboard.addKey("SPACE");
        if(Phaser.Input.Keyboard.JustDown(spacBar)){
            if(blockReady){
                const position = crane.x;
                const currentCameraY = this.cameras.main.scrollY;
                
                let block = this.matter.add.image(
                    position, 
                    crane.y + crane.displayHeight/2 + attachedFloor.displayHeight,
                    'redBlockTexture'
                )
                .setBounce(0.08) // Slightly reduced bounce
                .setFriction(1) // Increased friction for more stability
                .setFrictionStatic(1.15) // Higher static friction
                .setDensity(0.9); // Slightly reduced density

                // Additional stability properties
                block.body.inertia = Infinity; // Prevents rotation from small forces
                block.body.inverseInertia = 0;

                const scaleToFitBlock = unifiedHeightUnit / block.height;
                block.setScale(scaleToFitBlock);

                latestBlock = block;
                block.body.label = 'buildingBlock';
                blockReady = false;
                currentScore += 1;
                
                // Update the HTML element instead of Phaser text
                currentScoreElement.textContent = 'Score: ' + currentScore;
            }
        }
    }
</script>

</body>
</html>